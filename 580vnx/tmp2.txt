inject:

i=0xd180 for j=1,110 do data[i]=0x30 i=i+1 end data[i]=0xfd data[i+1]=0x20

-- NOTE check if er14 should be set

-- 0x3a2: diff input and undo
i=0xd180 for j=1,34 do data[i]=0x30 i=i+1 end
i=-0x3a2+0xd53e for j in ('50 d5 33 31 30 32 ad 7c 31 30 22 a2 30 30 33 32 31 30 39 38 37 36 35 34 33 32 31 30 30 31 60 fe 01 fe 01'):gmatch('%w%w') do data[i]=tonumber(j,16) i=i+1 end
while i<0xd247 do data[i]=48 i=i+1 end -- fill to end


b(0xa222)
b(0x23f7c) -- end of checksum
-- b(0x23fc8) -- start
b(0x203D0) -- end of strcpy (NOTE: skip first time)


== seg 0 read. (emu)

52 a7 30 30 92 3f 32 30 31 32 33 34 35 36 fe 01 a0 3f 32 30 30 30 30 30 30 30 74 d5 14 3f 32 30 2e 2e 2e 2e 2e 2e 2e 2e 2e 2e 2e 2e 2e 2e 2e 2e 30 30 30 30 30 30 30 30 2c d5 52 d2 30 30 30 30 c8 03 32 30 01 40 32 30 c0 d2 30 30 30 30 30 30 58 9e 30 30 30 30 31 fe fe aa 30 29 52 d5 52 a7 30 30 fc aa 30 29


^^^ inject (in mode 90)

-- b(0x23f10)

COMMENT
	0x01,0x40,0x32,0x30, -- pop qr8
		0xbe,0xd1, -- er8 = inc address
		0x2e,0x2e,0x2e,0x2e,
		0x02,0xfe, -- er14 = count
	0x9c,0x3c,0x32,0x30, -- pop xr0
		0x30,0x30,
		0x32,0x32, -- er2: delta, should be even & not divisible by 4
	0x58,0x9e,0x30,0x30, -- [er8]+=er2
		0x31,0x31,0x30,0x30,
	0xc8,0x3f,0x32,0x30, -- calc checksum
		0x31,0x31,0x30,0x30,0x31,0x31,
		0x84,0xd5, -- er14
	0x14,0x3f,0x32,0x30, -- print checksum
		0x2e,0x2e,0x2e,0x2e,0x2e,0x2e,0x2e,0x2e,
		0x2e,0x2e,0x2e,0x2e,0x2e,0x2e,0x2e,0x2e,
		0x2e,0x2e,0x2e,0x2e,

		0x30,0x30,0x30,0x30,0x30,0x30, -- qr8
			0x34,0xd5, -- er14
		0x72,0xd4,0xd0,0xd0, -- er0: dest, er2: src
			0x30,0x30,0x34,0xd5, -- qr0

	0x96,0xaa,0x30,0x30, -- memmove
		0xfe,0x02, -- move size

b(0x23f6c)


for i=1,50 do del(i) end

# for i=0,30 do wa(0xd392+i,function() if not calling then bt() end p(' mod ',i) c() end) end
calling=false
for _,v in pairs({0x1e7e0,0x1e7fe,0x1e81c,0x1e82e,0x1e846,0x1e868}) do b(v,function() calling=true p('Caller:') ins() ppc() c() end) b(v+4,function() calling=false p('  Done') c() end) end


ignored: memset, move when there is old hist
