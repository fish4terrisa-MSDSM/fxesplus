# Test writing to/reading from segments other than 0 using boot initialization routine.
# => Success.
# Replace initial er10 = 0x40 with 0x30 => still success.

	adr_of [-10] x # er12
	0x33  # 4 bytes [xr8]
	0x31
	0x30  # er10 = 0 (mod 16) [segment index]
	0x32

home:
	call 0x16058  # lea [er12]; st r0..r9 -> [ea+]; rt

	call 0x4876 # noreturn?


#0x30313233343536373839 # 10 bytes, will be overwritten  [not necessary because usually the data is not at the same place as the code]

x:

#	source;  dest ; count ; sseg; dseg

# test 8:f801
	0x3130; 0xf801; 0x0101; 0x31; 0x38
	0xf801; 0xf868; 0x0101; 0x38; 0x30
	0x3233; 0x3233; 0xae30; 0x31; 0x31   # DELAY

# test 2:f801 [is it equivalent to 0:f830?]
	0x3130; 0xf801; 0x0101; 0x31; 0x32
	0xf801; 0xf846; 0x0101; 0x32; 0x30
	0x3233; 0x3233; 0xae30; 0x31; 0x31   # DELAY

# test 0:f200
	0x3130; 0xf201; 0x0101; 0x31; 0x30
	0xf201; 0xf836; 0x0101; 0x30; 0x30
	0x3233; 0x3233; 0xae30; 0x31; 0x31   # DELAY

# test 0:fc30
	0x3130; 0xfc30; 0x0101; 0x31; 0x30
	0xfc30; 0xf876; 0x0101; 0x30; 0x30
	0x3233; 0x3233; 0xae30; 0x31; 0x31   # DELAY

# test 8:f830
	0x3130; 0xf830; 0x0101; 0x31; 0x38
	0xf830; 0xf846; 0x0101; 0x38; 0x30
	0x3233; 0x3233; 0xae30; 0x31; 0x31   # DELAY

# test 0:9830
	0x3130; 0x9830; 0x0101; 0x31; 0x30
	0x9830; 0xf836; 0x0101; 0x30; 0x30
	0x3233; 0x3233; 0xae30; 0x31; 0x31   # DELAY

	0x3130; 0xf830; 0x0101; 0x31; 0x30   # example. must work



# 30, 36, 41, 46, 60, 68, 76


